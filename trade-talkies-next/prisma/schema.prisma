generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  uid         String   @unique
  email       String   @unique
  username    String
  displayName String?
  photoURL    String?
  interests   String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  joinedRoomsIDs String[] @db.ObjectId
  joinedRooms    Room[]   @relation(fields: [joinedRoomsIDs], references: [id])
  
  ownedRooms     Room[]   @relation("RoomOwner")
}

model Room {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  description String?
  tags        String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  ownerId     String   @db.ObjectId // This should probably be the User's internal ID, but the Mongoose schema referenced User.
  // However, in the Mongoose schema provided: owner: { type: String, required: true } (likely UID)
  // Let's check the Mongoose schema again.
  // "owner: { type: String, required: true }" -> This is likely the Firebase UID.
  // But "joinedRooms: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Room' }]"
  
  // To keep it simple and consistent with Prisma + MongoDB:
  // We will store the User's internal ObjectId for relations if possible, OR the UID.
  // Given the Mongoose schema used `ref: 'Room'`, it was using ObjectIds.
  // But `owner` was a String. Let's assume `owner` is the Firebase UID for now to match legacy.
  ownerUid    String   
  
  // Many-to-Many with User
  memberIDs   String[] @db.ObjectId
  members     User[]   @relation(fields: [memberIDs], references: [id])
  
  // Inverse relation for owner (optional, if we want to link by UID we can't easily do it in Prisma relations without a unique constraint on UID in User, which we have)
  owner       User     @relation("RoomOwner", fields: [ownerUid], references: [uid])

  channels    Channel[]
}

type Channel {
  id   String @default(uuid()) // Subdocuments in Mongoose usually have _id. We can use UUID or ObjectId.
  name String
  type String // 'text' | 'voice'
}

model Message {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  channelId String   // This matches the ID inside the Room's channels array
  roomId    String   @db.ObjectId // Useful for faster lookups
  content   String
  type      String   @default("text") // 'text' | 'image'
  timestamp DateTime @default(now())

  // Sender info (denormalized in Mongoose, but we can link to User)
  senderUid      String
  senderUsername String
  senderPhotoURL String?
  
  // Optional: Link to User model if needed
  // sender User @relation(fields: [senderUid], references: [uid])
}
